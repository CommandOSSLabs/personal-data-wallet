# Complete Guide to Using Seal Packages

## Table of Contents
1. [Overview](#overview)
2. [Core Architecture](#core-architecture) 
3. [Package Installation](#package-installation)
4. [Key Concepts](#key-concepts)
5. [Basic Setup](#basic-setup)
6. [Frontend Integration](#frontend-integration)
7. [Usage Examples](#usage-examples)
8. [Best Practices](#best-practices)
9. [Troubleshooting](#troubleshooting)

## Overview

**Seal** is a decentralized secrets management (DSM) service built by MystenLabs that enables developers to secure sensitive data with onchain access control policies. Seal leverages Sui for controlling access to the decryption keys, and thus allows access control for the sensitive data itself. Seal enables identity-based encryption and decryption of sensitive data, with access controlled by onchain policies on Sui.

### Key Features:
- **Identity-based encryption** with client-side encryption/decryption
- **Threshold encryption** using t-of-n key server architecture
- **Onchain access control** via Sui Move smart contracts
- **Flexible storage integration** (Walrus, IPFS, or any storage solution)
- **Developer-friendly TypeScript SDK**

## Core Architecture

Seal operates on a three-layer architecture:

### 1. **Onchain Access Policies (Sui)**
- Move smart contracts define `seal_approve*` functions
- Package ID creates identity namespace: `[PkgId][identity]`
- Access rules are transparent and auditable onchain

### 2. **Key Servers (Offchain)**  
- Different parties can operate their own Seal key servers, thus allowing users to realize t-out-of-n threshold encryption
- Generate identity-based private keys for decryption
- Validate access policies via dry-run transactions on Sui full nodes

### 3. **Client Applications**
- Use TypeScript SDK for encryption/decryption
- Handle user authentication and wallet integration
- Manage encrypted data storage and retrieval

## Package Installation

### Primary Package

```bash
npm install @mysten/seal
```

Latest version: 0.5.2+ (Note: Recent versions have removed the `getAllowlistedKeyServers()` function)

### Essential Dependencies

```bash
# Sui TypeScript SDK (required)
npm install @mysten/sui

# dApp Kit for wallet integration (recommended)
npm install @mysten/dapp-kit

# Additional UI dependencies for React apps
npm install @tanstack/react-query react
```

### Optional Dependencies

```bash
# For advanced BCS operations
npm install @mysten/bcs

# For Walrus storage integration  
npm install @mysten/walrus

# For local development and testing
npm install @mysten/sui-test
```

## Key Concepts

### 1. **Identity-Based Encryption (IBE)**
- Each encrypted piece of data has a unique identity: `[PackageId][CustomIdentity]`
- Public keys are derived from identities for encryption
- Private keys are generated by key servers for decryption

### 2. **Access Control Functions**
```move
// Example seal_approve function in Move
entry fun seal_approve_allowlist(
    id: vector<u8>,
    allowlist: &Allowlist,
    ctx: &mut TxContext
) {
    let sender = tx_context::sender(ctx);
    assert!(is_member(allowlist, sender), ENotMember);
    // Access granted if assertion passes
}
```

### 3. **Session Keys**
- The session key allows the dApp to retrieve associated decryption keys for a limited time without requiring repeated user confirmations
- Created once per package per user
- Stored in localStorage or IndexedDB

### 4. **Threshold Encryption**
- Select multiple key servers (e.g., 3 servers)
- Set threshold (e.g., 2-of-3)
- Data remains secure if fewer than threshold servers are compromised

## Basic Setup

### 1. **Initialize Sui Client**

```typescript
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';

const suiClient = new SuiClient({ 
  url: getFullnodeUrl('testnet') // or 'mainnet', 'devnet'
});
```

### 2. **Configure Key Servers**

```typescript
import { SealClient, getAllowlistedKeyServers } from '@mysten/seal';

// Use verified key servers
const serverObjectIds = getAllowlistedKeyServers('testnet');

// Or specify custom servers
const customServerIds = [
  '0x123...', // Server 1 object ID
  '0x456...', // Server 2 object ID  
  '0x789...', // Server 3 object ID
];

const client = new SealClient({
  suiClient,
  serverConfigs: serverObjectIds.map((id) => ({
    objectId: id,
    weight: 1, // Server voting weight
  })),
  verifyKeyServers: true, // Verify server authenticity
});
```

### 3. **Setup Session Key** 

```typescript
import { SessionKey } from '@mysten/seal';

// Create session key for user authorization
const sessionKey = new SessionKey({
  packageId: '0xYourPackageId',
  userId: 'user@example.com', // Optional identifier
  mvr_name: 'your-package-name', // Move Registry name (optional)
});

// Store session key
sessionKey.save(); // Uses localStorage by default

// Or use IndexedDB for cross-tab persistence
await sessionKey.saveToIndexedDB();
```

## Frontend Integration

### 1. **React Component Setup**

```typescript
import { useState, useEffect } from 'react';
import { SuiClient } from '@mysten/sui/client';
import { SealClient } from '@mysten/seal';
import { useWallet } from '@mysten/dapp-kit';

export function SealProvider({ children }) {
  const { currentWallet } = useWallet();
  const [sealClient, setSealClient] = useState<SealClient | null>(null);

  useEffect(() => {
    const initSeal = async () => {
      const suiClient = new SuiClient({ 
        url: getFullnodeUrl('testnet') 
      });
      
      const serverIds = getAllowlistedKeyServers('testnet');
      
      const client = new SealClient({
        suiClient,
        serverConfigs: serverIds.map(id => ({ 
          objectId: id, 
          weight: 1 
        })),
        verifyKeyServers: true,
      });
      
      setSealClient(client);
    };

    initSeal();
  }, []);

  return (
    <SealContext.Provider value={{ sealClient }}>
      {children}
    </SealContext.Provider>
  );
}
```

### 2. **Wallet Integration with dApp Kit**

```typescript
import { ConnectButton, WalletProvider } from '@mysten/dapp-kit';

function App() {
  return (
    <WalletProvider>
      <SealProvider>
        <ConnectButton />
        <EncryptionDemo />
      </SealProvider>
    </WalletProvider>
  );
}
```

## Usage Examples

### 1. **Basic File Encryption**

```typescript
async function encryptFile(
  file: File, 
  identity: string,
  sealClient: SealClient
): Promise<string> {
  // Read file as bytes
  const fileBytes = new Uint8Array(await file.arrayBuffer());
  
  // Encrypt with Seal
  const encryptedData = await sealClient.encrypt(
    fileBytes,
    identity // e.g., "file_123" or "user_doc_456"  
  );
  
  // Store encrypted data (e.g., on Walrus, IPFS)
  const storageUrl = await uploadToStorage(encryptedData);
  
  return storageUrl;
}
```

### 2. **File Decryption with Access Control**

```typescript
import { Transaction } from '@mysten/sui/transactions';

async function decryptFile(
  encryptedDataUrl: string,
  identity: string,
  packageId: string,
  sealClient: SealClient,
  wallet: any
): Promise<Uint8Array> {
  // Create transaction with seal_approve function
  const tx = new Transaction();
  
  // Call the access control function
  tx.moveCall({
    target: `${packageId}::access_control::seal_approve_member`,
    arguments: [
      tx.pure.string(identity), // Identity being requested
      tx.object(allowlistObjectId), // Allowlist object  
    ],
  });
  
  // Download encrypted data
  const encryptedData = await downloadFromStorage(encryptedDataUrl);
  
  // Decrypt using Seal client
  const decryptedData = await sealClient.decrypt(
    encryptedData,
    identity,
    tx, // Transaction with access control logic
    wallet
  );
  
  return decryptedData;
}
```

### 3. **Subscription-Based Access**

```typescript
// Move contract function for subscription access
entry fun seal_approve_subscription(
    id: vector<u8>,
    subscription_nft: &SubscriptionNFT,
    clock: &Clock,
    ctx: &TxContext
) {
    let current_time = clock::timestamp_ms(clock);
    let owner = tx_context::sender(ctx);
    
    assert!(subscription_nft.owner == owner, ENotOwner);
    assert!(subscription_nft.expires_at > current_time, EExpired);
    
    // Access granted for valid subscription
}

// Frontend usage
async function decryptSubscriptionContent(
  contentId: string,
  subscriptionNftId: string,
  sealClient: SealClient
) {
  const tx = new Transaction();
  
  tx.moveCall({
    target: `${PACKAGE_ID}::subscription::seal_approve_subscription`,
    arguments: [
      tx.pure.string(contentId),
      tx.object(subscriptionNftId),
      tx.object(SUI_CLOCK_OBJECT_ID),
    ],
  });
  
  return await sealClient.decrypt(
    encryptedContent,
    contentId,
    tx,
    wallet
  );
}
```

### 4. **Time-Lock Encryption**

```typescript
// Encrypt content to be unlocked at future time
async function createTimeLockedContent(
  data: Uint8Array,
  unlockTime: number, // Unix timestamp
  sealClient: SealClient
) {
  const identity = `timelock_${unlockTime}`;
  
  const encrypted = await sealClient.encrypt(data, identity);
  
  return {
    encrypted,
    identity,
    unlockTime
  };
}

// Decrypt when time condition is met
async function decryptTimeLocked(
  encrypted: Uint8Array,
  identity: string,
  packageId: string,
  sealClient: SealClient
) {
  const tx = new Transaction();
  
  tx.moveCall({
    target: `${packageId}::timelock::seal_approve_time`,
    arguments: [
      tx.pure.string(identity),
      tx.object(SUI_CLOCK_OBJECT_ID),
    ],
  });
  
  return await sealClient.decrypt(encrypted, identity, tx, wallet);
}
```

### 5. **Allowlist Management**

```typescript
// Frontend allowlist management
class AllowlistManager {
  constructor(
    private packageId: string,
    private allowlistObjectId: string,
    private sealClient: SealClient
  ) {}
  
  async addMember(memberAddress: string, wallet: any) {
    const tx = new Transaction();
    
    tx.moveCall({
      target: `${this.packageId}::allowlist::add_member`,
      arguments: [
        tx.object(this.allowlistObjectId),
        tx.pure.address(memberAddress),
      ],
    });
    
    const result = await wallet.signAndExecuteTransaction({
      transaction: tx,
    });
    
    return result;
  }
  
  async checkAccess(identity: string, userAddress: string) {
    const tx = new Transaction();
    
    tx.moveCall({
      target: `${this.packageId}::allowlist::seal_approve_allowlist`,
      arguments: [
        tx.pure.string(identity),
        tx.object(this.allowlistObjectId),
      ],
    });
    
    try {
      await this.sealClient.decrypt(
        dummyEncrypted, // Test decryption
        identity,
        tx,
        { address: userAddress }
      );
      return true;
    } catch (error) {
      return false;
    }
  }
}
```

## Best Practices

### 1. **Security Considerations**

- **Never store private keys client-side** - Seal handles key derivation through key servers
- **Use verified key servers** - Stick to allowlisted servers for production
- **Implement proper session management** - Session keys have limited lifespans
- Users are strongly advised not to connect their primary wallets or upload any sensitive content while utilizing this application during development

### 2. **Access Control Design**

- **Make `seal_approve*` functions deterministic** - Avoid randomness or time-dependent logic that varies across nodes
- seal_approve* functions must be side-effect free and cannot modify onchain state
- **Version your shared objects** for upgradeable contracts
- **Test access control logic** using Move unit tests

### 3. **Performance Optimization**

- **Cache session keys** - Avoid repeated wallet confirmations
- **Use appropriate key server weights** - Distribute load across reliable servers  
- **Batch operations** - Group multiple access requests when possible
- **Handle network failures gracefully** - Implement retry logic for key server requests

### 4. **User Experience**

```typescript
// Improved UX with loading states
const [isDecrypting, setIsDecrypting] = useState(false);
const [decryptionError, setDecryptionError] = useState(null);

const handleDecrypt = async () => {
  try {
    setIsDecrypting(true);
    setDecryptionError(null);
    
    const result = await decryptContent(contentId);
    
    // Show success state
    setDecryptedContent(result);
  } catch (error) {
    // Handle specific error types
    if (error.message.includes('access denied')) {
      setDecryptionError('You do not have permission to access this content');
    } else if (error.message.includes('network')) {
      setDecryptionError('Network error. Please try again.');
    } else {
      setDecryptionError('Failed to decrypt content');
    }
  } finally {
    setIsDecrypting(false);
  }
};
```

### 5. **Error Handling**

```typescript
// Comprehensive error handling
async function safeDecrypt(
  encryptedData: Uint8Array,
  identity: string,
  tx: Transaction,
  wallet: any
): Promise<Uint8Array | null> {
  try {
    return await sealClient.decrypt(encryptedData, identity, tx, wallet);
  } catch (error) {
    if (error.code === 'WALLET_NOT_CONNECTED') {
      // Prompt user to connect wallet
      await connectWallet();
      return null;
    } else if (error.code === 'ACCESS_DENIED') {
      // User doesn't have permission
      console.warn('Access denied for identity:', identity);
      return null;
    } else if (error.code === 'KEY_SERVER_UNAVAILABLE') {
      // Try with different key servers
      console.warn('Key server unavailable, retrying...');
      await delay(1000);
      return safeDecrypt(encryptedData, identity, tx, wallet);
    } else {
      // Unexpected error
      console.error('Decryption failed:', error);
      throw error;
    }
  }
}
```

## Troubleshooting

### Common Issues

1. **"Access Denied" Errors**
   - Verify `seal_approve*` function logic
   - Check that user meets access criteria
   - Ensure transaction calls correct function

2. **Key Server Connection Issues**
   - Verify server object IDs are correct
   - Check network connectivity
   - Try different key server combinations

3. **Session Key Problems**
   - Clear localStorage/IndexedDB
   - Recreate session key with correct package ID
   - Verify wallet is connected

4. **Transaction Failures**
   - Check gas limits and fees
   - Verify Move function signatures
   - Ensure objects exist onchain

### Debug Mode

```typescript
// Enable detailed logging
const sealClient = new SealClient({
  suiClient,
  serverConfigs,
  debug: true, // Enable debug logs
  timeout: 30000, // Increase timeout for debugging
});
```

### Testing Setup

```typescript
// Test environment configuration
const testSuiClient = new SuiClient({
  url: getFullnodeUrl('devnet') // Use devnet for testing
});

const testServers = getAllowlistedKeyServers('devnet');

// Mock data for testing
const mockEncryptedData = new Uint8Array([/* test data */]);
const testIdentity = 'test_identity_123';
```

## Advanced Usage

### Custom Key Server Integration

```typescript
// Using custom key servers
const customClient = new SealClient({
  suiClient,
  serverConfigs: [
    { objectId: '0xcustom1...', weight: 2 }, // Higher weight
    { objectId: '0xcustom2...', weight: 1 },
    { objectId: '0xcustom3...', weight: 1 },
  ],
  threshold: 2, // Require 2 servers for decryption
  verifyKeyServers: false, // Skip verification for custom servers
});
```

### Integration with Walrus Storage

```typescript
async function storeOnWalrus(
  data: Uint8Array,
  identity: string
): Promise<string> {
  // Encrypt data with Seal
  const encrypted = await sealClient.encrypt(data, identity);
  
  // Store on Walrus
  const walrusClient = new WalrusClient();
  const blobId = await walrusClient.store(encrypted);
  
  return blobId;
}

async function retrieveFromWalrus(
  blobId: string,
  identity: string,
  accessTx: Transaction
): Promise<Uint8Array> {
  // Retrieve from Walrus
  const walrusClient = new WalrusClient();
  const encrypted = await walrusClient.read(blobId);
  
  // Decrypt with Seal
  const decrypted = await sealClient.decrypt(
    encrypted,
    identity,
    accessTx,
    wallet
  );
  
  return decrypted;
}
```

This guide provides a comprehensive overview of using Seal packages for building secure, decentralized applications with sophisticated access control mechanisms. The combination of client-side encryption, onchain policies, and threshold key management makes Seal a powerful tool for Web3 developers building privacy-focused applications.