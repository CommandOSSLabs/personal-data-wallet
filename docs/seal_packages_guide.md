# Complete Guide to Using Seal Packages

## Table of Contents
1. [Overview](#overview)
2. [Core Architecture](#core-architecture) 
3. [Package Installation](#package-installation)
4. [Key Concepts](#key-concepts)
5. [Basic Setup](#basic-setup)
6. [Frontend Integration](#frontend-integration)
7. [Usage Examples](#usage-examples)
8. [Best Practices](#best-practices)
9. [Troubleshooting](#troubleshooting)

## Overview

**Seal** is a decentralized secrets management (DSM) service built by MystenLabs that enables developers to secure sensitive data with onchain access control policies. Seal leverages Sui for controlling access to the decryption keys, and thus allows access control for the sensitive data itself. Seal enables identity-based encryption and decryption of sensitive data, with access controlled by onchain policies on Sui.

### Key Features:
- **Identity-based encryption** with client-side encryption/decryption
- **Threshold encryption** using t-of-n key server architecture
- **Onchain access control** via Sui Move smart contracts
- **Flexible storage integration** (Walrus, IPFS, or any storage solution)
- **Developer-friendly TypeScript SDK**

## Core Architecture

Seal operates on a three-layer architecture:

### 1. **Onchain Access Policies (Sui)**
- Move smart contracts define `seal_approve*` functions
- Package ID creates identity namespace: `[PkgId][identity]`
- Access rules are transparent and auditable onchain

### 2. **Key Servers (Offchain)**  
- Different parties can operate their own Seal key servers, thus allowing users to realize t-out-of-n threshold encryption
- Generate identity-based private keys for decryption
- Validate access policies via dry-run transactions on Sui full nodes

### 3. **Client Applications**
- Use TypeScript SDK for encryption/decryption
- Handle user authentication and wallet integration
- Manage encrypted data storage and retrieval

## Package Installation

### Primary Package

```bash
npm install @mysten/seal
```

Latest version: 0.5.2+ (Note: Recent versions have removed the `getAllowlistedKeyServers()` function)

### Essential Dependencies

```bash
# Sui TypeScript SDK (required)
npm install @mysten/sui

# dApp Kit for wallet integration (recommended)
npm install @mysten/dapp-kit

# Additional UI dependencies for React apps
npm install @tanstack/react-query react
```

### Optional Dependencies

```bash
# For advanced BCS operations
npm install @mysten/bcs

# For Walrus storage integration  
npm install @mysten/walrus

# For local development and testing
npm install @mysten/sui-test
```

## Key Concepts

### 1. **Identity-Based Encryption (IBE)**
- Each encrypted piece of data has a unique identity: `[PackageId][CustomIdentity]`
- Public keys are derived from identities for encryption
- Private keys are generated by key servers for decryption

### 2. **Access Control Functions**
```move
// Example seal_approve function in Move
entry fun seal_approve_allowlist(
    id: vector<u8>,
    allowlist: &Allowlist,
    ctx: &mut TxContext
) {
    let sender = tx_context::sender(ctx);
    assert!(is_member(allowlist, sender), ENotMember);
    // Access granted if assertion passes
}
```

### 3. **Session Keys**
- The session key allows the dApp to retrieve associated decryption keys for a limited time without requiring repeated user confirmations
- Created once per package per user
- Stored in localStorage or IndexedDB

### 4. **Threshold Encryption**
- Select multiple key servers (e.g., 3 servers)
- Set threshold (e.g., 2-of-3)
- Data remains secure if fewer than threshold servers are compromised

## Basic Setup

### 1. **Initialize Sui Client**

```typescript
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';

const suiClient = new SuiClient({ 
  url: getFullnodeUrl('testnet') // or 'mainnet', 'devnet'
});
```

### 2. **Configure Key Servers**

```typescript
import { SealClient } from '@mysten/seal';

// Official Mysten Labs Testnet Key Servers (Verified)
const TESTNET_KEY_SERVERS = [
  {
    objectId: "0x73d05d62c18d9374e3ea529e8e0ed6161da1a141a94d3f76ae3fe4e99356db75",
    url: "https://seal-key-server-testnet-1.mystenlabs.com",
    mode: "Open"
  },
  {
    objectId: "0xf5d14a81a982144ae441cd7d64b09027f116a468bd36e7eca494f750591623c8", 
    url: "https://seal-key-server-testnet-2.mystenlabs.com",
    mode: "Open"
  }
];

// Production client setup
const sealClient = new SealClient({
  suiClient,
  serverConfigs: TESTNET_KEY_SERVERS.map(server => ({
    objectId: server.objectId,
    weight: 1, // Equal weight for threshold
  })),
  verifyKeyServers: false, // Set to true for production
  timeout: 30000, // 30 second timeout
  debug: false, // Enable for troubleshooting
});

// Custom server configuration (for advanced use cases)
const customServerIds = [
  '0x123...', // Server 1 object ID
  '0x456...', // Server 2 object ID  
  '0x789...', // Server 3 object ID
];

const customClient = new SealClient({
  suiClient,
  serverConfigs: customServerIds.map(id => ({
    objectId: id,
    weight: 1,
  })),
  threshold: 2, // Require 2-of-3 servers
  verifyKeyServers: false, // Skip verification for custom servers
});
```

### 3. **Setup Session Key Management**

```typescript
import { SessionKey, type ExportedSessionKey } from '@mysten/seal';
import { set, get } from 'idb-keyval';

// Session key management class
class SessionKeyManager {
  private static readonly TTL_MINUTES = 10;
  private keys = new Map<string, SessionKey>();
  
  /// Create session key for user
  async createSessionKey(
    userAddress: string,
    packageId: string,
    mvrName?: string
  ): Promise<SessionKey> {
    const sessionKey = await SessionKey.create({
      address: userAddress,
      packageId,
      ttlMin: SessionKeyManager.TTL_MINUTES,
      suiClient,
      mvrName,
    });
    
    // Cache in memory
    const keyId = `${userAddress}_${packageId}`;
    this.keys.set(keyId, sessionKey);
    
    return sessionKey;
  }
  
  /// Get or create session key with persistence
  async getOrCreateSessionKey(
    userAddress: string,
    packageId: string,
    mvrName?: string
  ): Promise<SessionKey> {
    const keyId = `${userAddress}_${packageId}`;
    
    // Check memory cache
    if (this.keys.has(keyId)) {
      const sessionKey = this.keys.get(keyId)!;
      if (!sessionKey.isExpired()) {
        return sessionKey;
      }
    }
    
    // Try to load from IndexedDB
    try {
      const stored: ExportedSessionKey = await get(`sessionKey_${keyId}`);
      if (stored) {
        const sessionKey = await SessionKey.import(stored, suiClient);
        if (!sessionKey.isExpired() && sessionKey.getAddress() === userAddress) {
          this.keys.set(keyId, sessionKey);
          return sessionKey;
        }
      }
    } catch (error) {
      console.warn('Failed to load stored session key:', error);
    }
    
    // Create new session key
    const sessionKey = await this.createSessionKey(userAddress, packageId, mvrName);
    
    // Persist to IndexedDB
    try {
      await set(`sessionKey_${keyId}`, sessionKey.export());
    } catch (error) {
      console.warn('Failed to persist session key:', error);
    }
    
    return sessionKey;
  }
  
  /// Setup personal message signing
  async setupPersonalMessage(
    sessionKey: SessionKey,
    signPersonalMessage: (params: { message: string }) => Promise<{ signature: string }>
  ): Promise<void> {
    if (sessionKey.getPersonalMessageSignature()) {
      return; // Already signed
    }
    
    const { signature } = await signPersonalMessage({
      message: sessionKey.getPersonalMessage()
    });
    
    await sessionKey.setPersonalMessageSignature(signature);
    
    // Update persisted version
    const keyId = `${sessionKey.getAddress()}_${sessionKey.getPackageId()}`;
    await set(`sessionKey_${keyId}`, sessionKey.export());
  }
  
  /// Clear expired session keys
  async clearExpiredKeys(): Promise<void> {
    for (const [keyId, sessionKey] of this.keys.entries()) {
      if (sessionKey.isExpired()) {
        this.keys.delete(keyId);
        await set(`sessionKey_${keyId}`, null);
      }
    }
  }
}

// React hook for session key management
export function useSessionKey(packageId: string, mvrName?: string) {
  const { currentAccount } = useCurrentAccount();
  const { mutate: signPersonalMessage } = useSignPersonalMessage();
  const [sessionKeyManager] = useState(() => new SessionKeyManager());
  const [sessionKey, setSessionKey] = useState<SessionKey | null>(null);
  const [loading, setLoading] = useState(false);
  
  const initializeSessionKey = useCallback(async () => {
    if (!currentAccount?.address) return;
    
    setLoading(true);
    try {
      const key = await sessionKeyManager.getOrCreateSessionKey(
        currentAccount.address,
        packageId,
        mvrName
      );
      
      // Setup personal message signing if needed
      await new Promise((resolve, reject) => {
        if (key.getPersonalMessageSignature()) {
          resolve(key);
          return;
        }
        
        signPersonalMessage(
          { message: key.getPersonalMessage() },
          {
            onSuccess: async (result: { signature: string }) => {
              try {
                await key.setPersonalMessageSignature(result.signature);
                resolve(key);
              } catch (error) {
                reject(error);
              }
            },
            onError: reject
          }
        );
      });
      
      setSessionKey(key);
    } catch (error) {
      console.error('Failed to initialize session key:', error);
    } finally {
      setLoading(false);
    }
  }, [currentAccount, packageId, mvrName, sessionKeyManager, signPersonalMessage]);
  
  useEffect(() => {
    initializeSessionKey();
  }, [initializeSessionKey]);
  
  return {
    sessionKey,
    loading,
    reinitialize: initializeSessionKey,
  };
}
```

## Frontend Integration

### 1. **React Component Setup**

```typescript
import { useState, useEffect } from 'react';
import { SuiClient } from '@mysten/sui/client';
import { SealClient } from '@mysten/seal';
import { useWallet } from '@mysten/dapp-kit';

export function SealProvider({ children }) {
  const { currentWallet } = useWallet();
  const [sealClient, setSealClient] = useState<SealClient | null>(null);

  useEffect(() => {
    const initSeal = async () => {
      const suiClient = new SuiClient({ 
        url: getFullnodeUrl('testnet') 
      });
      
     
      
      const client = new SealClient({
        suiClient,
        serverConfigs: serverIds.map(id => ({ 
          objectId: id, 
          weight: 1 
        })),
        verifyKeyServers: true,
      });
      
      setSealClient(client);
    };

    initSeal();
  }, []);

  return (
    <SealContext.Provider value={{ sealClient }}>
      {children}
    </SealContext.Provider>
  );
}
```

### 2. **Wallet Integration with dApp Kit**

```typescript
import { ConnectButton, WalletProvider } from '@mysten/dapp-kit';

function App() {
  return (
    <WalletProvider>
      <SealProvider>
        <ConnectButton />
        <EncryptionDemo />
      </SealProvider>
    </WalletProvider>
  );
}
```

## Usage Examples

### 1. **Basic File Encryption**

```typescript
async function encryptFile(
  file: File, 
  identity: string,
  sealClient: SealClient
): Promise<string> {
  // Read file as bytes
  const fileBytes = new Uint8Array(await file.arrayBuffer());
  
  // Encrypt with Seal
  const encryptedData = await sealClient.encrypt(
    fileBytes,
    identity // e.g., "file_123" or "user_doc_456"  
  );
  
  // Store encrypted data (e.g., on Walrus, IPFS)
  const storageUrl = await uploadToStorage(encryptedData);
  
  return storageUrl;
}
```

### 2. **File Decryption with Access Control**

```typescript
import { Transaction } from '@mysten/sui/transactions';

async function decryptFile(
  encryptedDataUrl: string,
  identity: string,
  packageId: string,
  sealClient: SealClient,
  wallet: any
): Promise<Uint8Array> {
  // Create transaction with seal_approve function
  const tx = new Transaction();
  
  // Call the access control function
  tx.moveCall({
    target: `${packageId}::access_control::seal_approve_member`,
    arguments: [
      tx.pure.string(identity), // Identity being requested
      tx.object(allowlistObjectId), // Allowlist object  
    ],
  });
  
  // Download encrypted data
  const encryptedData = await downloadFromStorage(encryptedDataUrl);
  
  // Decrypt using Seal client
  const decryptedData = await sealClient.decrypt(
    encryptedData,
    identity,
    tx, // Transaction with access control logic
    wallet
  );
  
  return decryptedData;
}
```

### 3. **Subscription-Based Access**

```typescript
// Move contract function for subscription access
entry fun seal_approve_subscription(
    id: vector<u8>,
    subscription_nft: &SubscriptionNFT,
    clock: &Clock,
    ctx: &TxContext
) {
    let current_time = clock::timestamp_ms(clock);
    let owner = tx_context::sender(ctx);
    
    assert!(subscription_nft.owner == owner, ENotOwner);
    assert!(subscription_nft.expires_at > current_time, EExpired);
    
    // Access granted for valid subscription
}

// Frontend usage
async function decryptSubscriptionContent(
  contentId: string,
  subscriptionNftId: string,
  sealClient: SealClient
) {
  const tx = new Transaction();
  
  tx.moveCall({
    target: `${PACKAGE_ID}::subscription::seal_approve_subscription`,
    arguments: [
      tx.pure.string(contentId),
      tx.object(subscriptionNftId),
      tx.object(SUI_CLOCK_OBJECT_ID),
    ],
  });
  
  return await sealClient.decrypt(
    encryptedContent,
    contentId,
    tx,
    wallet
  );
}
```

### 4. **Time-Lock Encryption**

```typescript
// Encrypt content to be unlocked at future time
async function createTimeLockedContent(
  data: Uint8Array,
  unlockTime: number, // Unix timestamp
  sealClient: SealClient
) {
  const identity = `timelock_${unlockTime}`;
  
  const encrypted = await sealClient.encrypt(data, identity);
  
  return {
    encrypted,
    identity,
    unlockTime
  };
}

// Decrypt when time condition is met
async function decryptTimeLocked(
  encrypted: Uint8Array,
  identity: string,
  packageId: string,
  sealClient: SealClient
) {
  const tx = new Transaction();
  
  tx.moveCall({
    target: `${packageId}::timelock::seal_approve_time`,
    arguments: [
      tx.pure.string(identity),
      tx.object(SUI_CLOCK_OBJECT_ID),
    ],
  });
  
  return await sealClient.decrypt(encrypted, identity, tx, wallet);
}
```

### 5. **Allowlist Management (Official Pattern)**

#### Move Contract Implementation
```move
// allowlist.move - Based on official SEAL examples
module memory_wallet::allowlist {
    use std::string::String;
    use sui::dynamic_field as df;
    
    const EInvalidCap: u64 = 0;
    const ENoAccess: u64 = 1;
    const EDuplicate: u64 = 2;
    const MARKER: u64 = 3;
    
    public struct Allowlist has key {
        id: UID,
        name: String,
        list: vector<address>,
    }
    
    public struct Cap has key {
        id: UID,
        allowlist_id: ID,
    }
    
    /// Create allowlist with admin capability
    public fun create_allowlist(name: String, ctx: &mut TxContext): Cap {
        let allowlist = Allowlist {
            id: object::new(ctx),
            list: vector::empty(),
            name,
        };
        let cap = Cap {
            id: object::new(ctx),
            allowlist_id: object::id(&allowlist),
        };
        transfer::share_object(allowlist);
        cap
    }
    
    /// Entry function for easier CLI usage
    entry fun create_allowlist_entry(name: String, ctx: &mut TxContext) {
        transfer::transfer(create_allowlist(name, ctx), ctx.sender());
    }
    
    /// Add member to allowlist (requires admin cap)
    public fun add(allowlist: &mut Allowlist, cap: &Cap, account: address) {
        assert!(cap.allowlist_id == object::id(allowlist), EInvalidCap);
        assert!(!allowlist.list.contains(&account), EDuplicate);
        allowlist.list.push_back(account);
    }
    
    /// Remove member from allowlist (requires admin cap)
    public fun remove(allowlist: &mut Allowlist, cap: &Cap, account: address) {
        assert!(cap.allowlist_id == object::id(allowlist), EInvalidCap);
        allowlist.list = allowlist.list.filter!(|x| x != account);
    }
    
    /// Core SEAL approval function
    entry fun seal_approve(id: vector<u8>, allowlist: &Allowlist, ctx: &TxContext) {
        assert!(approve_internal(ctx.sender(), id, allowlist), ENoAccess);
    }
    
    /// Internal approval logic with prefix checking
    fun approve_internal(caller: address, id: vector<u8>, allowlist: &Allowlist): bool {
        // Check if id has correct allowlist namespace prefix
        let namespace = allowlist.id.to_bytes();
        if (!is_prefix(namespace, id)) {
            return false
        };
        // Verify caller is in allowlist
        allowlist.list.contains(&caller)
    }
    
    /// Attach encrypted content to allowlist
    public fun publish(allowlist: &mut Allowlist, cap: &Cap, blob_id: String) {
        assert!(cap.allowlist_id == object::id(allowlist), EInvalidCap);
        df::add(&mut allowlist.id, blob_id, MARKER);
    }
    
    /// Get allowlist namespace for encryption
    public fun namespace(allowlist: &Allowlist): vector<u8> {
        allowlist.id.to_bytes()
    }
}
```

#### Frontend Integration
```typescript
// Complete allowlist management with SEAL integration
class AllowlistManager {
  private sealClient: SealClient;
  private sessionKeyManager: SessionKeyManager;
  
  constructor(
    private packageId: string,
    private suiClient: SuiClient,
    sealClient: SealClient
  ) {
    this.sealClient = sealClient;
    this.sessionKeyManager = new SessionKeyManager();
  }
  
  /// Create new allowlist
  async createAllowlist(name: string, wallet: any): Promise<string> {
    const tx = new Transaction();
    tx.moveCall({
      target: `${this.packageId}::allowlist::create_allowlist_entry`,
      arguments: [tx.pure.string(name)],
    });
    tx.setGasBudget(10000000);
    
    const result = await wallet.signAndExecuteTransaction({ transaction: tx });
    
    // Extract created allowlist object ID
    const allowlistObject = result.effects?.created?.find(
      item => item.owner && typeof item.owner === 'object' && 'Shared' in item.owner
    );
    
    return allowlistObject?.reference?.objectId || '';
  }
  
  /// Add member to allowlist
  async addMember(
    allowlistId: string, 
    capId: string, 
    memberAddress: string, 
    wallet: any
  ): Promise<void> {
    const tx = new Transaction();
    tx.moveCall({
      target: `${this.packageId}::allowlist::add`,
      arguments: [
        tx.object(allowlistId),
        tx.object(capId),
        tx.pure.address(memberAddress)
      ],
    });
    tx.setGasBudget(10000000);
    
    await wallet.signAndExecuteTransaction({ transaction: tx });
  }
  
  /// Remove member from allowlist
  async removeMember(
    allowlistId: string,
    capId: string, 
    memberAddress: string,
    wallet: any
  ): Promise<void> {
    const tx = new Transaction();
    tx.moveCall({
      target: `${this.packageId}::allowlist::remove`,
      arguments: [
        tx.object(allowlistId),
        tx.object(capId),
        tx.pure.address(memberAddress)
      ],
    });
    tx.setGasBudget(10000000);
    
    await wallet.signAndExecuteTransaction({ transaction: tx });
  }
  
  /// Encrypt content for allowlist members
  async encryptForAllowlist(
    content: Uint8Array,
    allowlistId: string,
    nonce?: string
  ): Promise<{ encrypted: Uint8Array; identity: string }> {
    // Get allowlist object to derive namespace
    const allowlist = await this.suiClient.getObject({
      id: allowlistId,
      options: { showContent: true }
    });
    
    // Create identity: [allowlist_namespace][nonce]
    const namespace = allowlistId; // Simplified - should be allowlist.id.to_bytes()
    const identityNonce = nonce || Date.now().toString();
    const identity = `${namespace}_${identityNonce}`;
    
    const encrypted = await this.sealClient.encrypt(content, identity);
    return { encrypted, identity };
  }
  
  /// Decrypt content with allowlist access
  async decryptWithAllowlist(
    encryptedData: Uint8Array,
    identity: string,
    allowlistId: string,
    userAddress: string,
    signPersonalMessage: (params: any) => Promise<{ signature: string }>
  ): Promise<Uint8Array> {
    // Get or create session key
    const sessionKey = await this.sessionKeyManager.getOrCreateSessionKey(
      userAddress,
      this.packageId
    );
    
    // Sign personal message if needed
    if (!sessionKey.getPersonalMessageSignature()) {
      const { signature } = await signPersonalMessage({
        message: sessionKey.getPersonalMessage()
      });
      await sessionKey.setPersonalMessageSignature(signature);
    }
    
    // Create access control transaction
    const tx = new Transaction();
    tx.moveCall({
      target: `${this.packageId}::allowlist::seal_approve`,
      arguments: [
        tx.pure.vector('u8', fromHex(identity)),
        tx.object(allowlistId)
      ],
    });
    
    const txBytes = tx.build({ 
      client: this.suiClient, 
      onlyTransactionKind: true 
    });
    
    // Decrypt using SEAL client
    return await this.sealClient.decrypt({
      data: encryptedData,
      sessionKey,
      txBytes,
    });
  }
  
  /// Check if user has access to allowlist
  async checkAccess(
    allowlistId: string,
    userAddress: string
  ): Promise<boolean> {
    try {
      const allowlist = await this.suiClient.getObject({
        id: allowlistId,
        options: { showContent: true }
      });
      
      const fields = (allowlist.data?.content as { fields: any })?.fields || {};
      const memberList = fields.list || [];
      
      return memberList.includes(userAddress);
    } catch (error) {
      console.error('Error checking allowlist access:', error);
      return false;
    }
  }
}
```

#### React Hook for Allowlist Management
```typescript
// Custom hook for allowlist operations
export function useAllowlist(packageId: string, allowlistId?: string) {
  const { currentAccount } = useCurrentAccount();
  const { mutate: signPersonalMessage } = useSignPersonalMessage();
  const suiClient = useSuiClient();
  const [allowlistManager] = useState(
    () => new AllowlistManager(packageId, suiClient, sealClient)
  );
  
  const addMember = useCallback(async (memberAddress: string, capId: string) => {
    if (!currentAccount || !allowlistId) return;
    
    await allowlistManager.addMember(
      allowlistId,
      capId,
      memberAddress,
      currentAccount
    );
  }, [allowlistManager, allowlistId, currentAccount]);
  
  const decryptContent = useCallback(async (
    encryptedData: Uint8Array,
    identity: string
  ) => {
    if (!currentAccount?.address || !allowlistId) return null;
    
    return await allowlistManager.decryptWithAllowlist(
      encryptedData,
      identity,
      allowlistId,
      currentAccount.address,
      signPersonalMessage
    );
  }, [allowlistManager, allowlistId, currentAccount, signPersonalMessage]);
  
  return {
    addMember,
    decryptContent,
    checkAccess: (userAddress: string) => 
      allowlistManager.checkAccess(allowlistId!, userAddress),
  };
}
```

## Best Practices

### 1. **Security Considerations**

- **Never store private keys client-side** - Seal handles key derivation through key servers
- **Use verified key servers** - Stick to allowlisted servers for production
- **Implement proper session management** - Session keys have limited lifespans
- Users are strongly advised not to connect their primary wallets or upload any sensitive content while utilizing this application during development

### 2. **Access Control Design**

- **Make `seal_approve*` functions deterministic** - Avoid randomness or time-dependent logic that varies across nodes
- seal_approve* functions must be side-effect free and cannot modify onchain state
- **Version your shared objects** for upgradeable contracts
- **Test access control logic** using Move unit tests

### 3. **Performance Optimization**

- **Cache session keys** - Avoid repeated wallet confirmations
- **Use appropriate key server weights** - Distribute load across reliable servers  
- **Batch operations** - Group multiple access requests when possible
- **Handle network failures gracefully** - Implement retry logic for key server requests

### 4. **User Experience**

```typescript
// Improved UX with loading states
const [isDecrypting, setIsDecrypting] = useState(false);
const [decryptionError, setDecryptionError] = useState(null);

const handleDecrypt = async () => {
  try {
    setIsDecrypting(true);
    setDecryptionError(null);
    
    const result = await decryptContent(contentId);
    
    // Show success state
    setDecryptedContent(result);
  } catch (error) {
    // Handle specific error types
    if (error.message.includes('access denied')) {
      setDecryptionError('You do not have permission to access this content');
    } else if (error.message.includes('network')) {
      setDecryptionError('Network error. Please try again.');
    } else {
      setDecryptionError('Failed to decrypt content');
    }
  } finally {
    setIsDecrypting(false);
  }
};
```

### 5. **Error Handling**

```typescript
// Comprehensive error handling
async function safeDecrypt(
  encryptedData: Uint8Array,
  identity: string,
  tx: Transaction,
  wallet: any
): Promise<Uint8Array | null> {
  try {
    return await sealClient.decrypt(encryptedData, identity, tx, wallet);
  } catch (error) {
    if (error.code === 'WALLET_NOT_CONNECTED') {
      // Prompt user to connect wallet
      await connectWallet();
      return null;
    } else if (error.code === 'ACCESS_DENIED') {
      // User doesn't have permission
      console.warn('Access denied for identity:', identity);
      return null;
    } else if (error.code === 'KEY_SERVER_UNAVAILABLE') {
      // Try with different key servers
      console.warn('Key server unavailable, retrying...');
      await delay(1000);
      return safeDecrypt(encryptedData, identity, tx, wallet);
    } else {
      // Unexpected error
      console.error('Decryption failed:', error);
      throw error;
    }
  }
}
```

## Troubleshooting

### Common Issues

1. **"Access Denied" Errors**
   - Verify `seal_approve*` function logic
   - Check that user meets access criteria
   - Ensure transaction calls correct function

2. **Key Server Connection Issues**
   - Verify server object IDs are correct
   - Check network connectivity
   - Try different key server combinations

3. **Session Key Problems**
   - Clear localStorage/IndexedDB
   - Recreate session key with correct package ID
   - Verify wallet is connected

4. **Transaction Failures**
   - Check gas limits and fees
   - Verify Move function signatures
   - Ensure objects exist onchain

### Debug Mode

```typescript
// Enable detailed logging
const sealClient = new SealClient({
  suiClient,
  serverConfigs,
  debug: true, // Enable debug logs
  timeout: 30000, // Increase timeout for debugging
});
```

### Testing Setup

```typescript
// Test environment configuration
const testSuiClient = new SuiClient({
  url: getFullnodeUrl('devnet') // Use devnet for testing
});


// Mock data for testing
const mockEncryptedData = new Uint8Array([/* test data */]);
const testIdentity = 'test_identity_123';
```

## Advanced Usage

### Custom Key Server Integration

```typescript
// Using custom key servers
const customClient = new SealClient({
  suiClient,
  serverConfigs: [
    { objectId: '0xcustom1...', weight: 2 }, // Higher weight
    { objectId: '0xcustom2...', weight: 1 },
    { objectId: '0xcustom3...', weight: 1 },
  ],
  threshold: 2, // Require 2 servers for decryption
  verifyKeyServers: false, // Skip verification for custom servers
});
```

### Integration with Walrus Storage

```typescript
async function storeOnWalrus(
  data: Uint8Array,
  identity: string
): Promise<string> {
  // Encrypt data with Seal
  const encrypted = await sealClient.encrypt(data, identity);
  
  // Store on Walrus
  const walrusClient = new WalrusClient();
  const blobId = await walrusClient.store(encrypted);
  
  return blobId;
}

async function retrieveFromWalrus(
  blobId: string,
  identity: string,
  accessTx: Transaction
): Promise<Uint8Array> {
  // Retrieve from Walrus
  const walrusClient = new WalrusClient();
  const encrypted = await walrusClient.read(blobId);
  
  // Decrypt with Seal
  const decrypted = await sealClient.decrypt(
    encrypted,
    identity,
    accessTx,
    wallet
  );
  
  return decrypted;
}
```

This guide provides a comprehensive overview of using Seal packages for building secure, decentralized applications with sophisticated access control mechanisms. The combination of client-side encryption, onchain policies, and threshold key management makes Seal a powerful tool for Web3 developers building privacy-focused applications.